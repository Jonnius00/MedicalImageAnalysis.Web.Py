"""
3D Volume Operations Module

This module provides functions for:
- Converting clustered image stacks to 3D volumes
- Extracting binary masks for specific clusters
- Generating 3D meshes using marching cubes algorithm
"""

import numpy as np
from skimage import measure
from scipy import ndimage


def extract_cluster_volume(labels_stack: np.ndarray, cluster_id: int) -> np.ndarray:
    """
    Extract a binary volume for a specific cluster from the labels stack.
    
    Args:
        labels_stack (np.ndarray): 3D array of cluster labels (num_slices, height, width)
        cluster_id (int): The cluster ID to extract
        
    Returns:
        np.ndarray: Binary 3D volume where True indicates the cluster
    """
    return (labels_stack == cluster_id).astype(np.uint8)


def smooth_volume(volume: np.ndarray, sigma: float = 1.0) -> np.ndarray:
    """
    Apply Gaussian smoothing to a 3D volume.
    
    This improves the quality of the mesh generated by marching cubes
    by reducing staircase artifacts.
    
    Args:
        volume (np.ndarray): Binary 3D volume
        sigma (float): Standard deviation for Gaussian kernel
        
    Returns:
        np.ndarray: Smoothed volume (float values 0-1)
    """
    return ndimage.gaussian_filter(volume.astype(np.float32), sigma=sigma)


def generate_mesh(volume: np.ndarray, 
                  level: float = 0.5, 
                  step_size: int = 1,
                  smooth: bool = True,
                  smooth_sigma: float = 1.0) -> dict:
    """
    Generate a 3D mesh from a binary volume using the marching cubes algorithm.
    
    Args:
        volume (np.ndarray): Binary 3D volume (num_slices, height, width)
        level (float): Contour value to search for isosurface (0-1 for smoothed volumes)
        step_size (int): Step size for marching cubes (higher = faster but less detail)
        smooth (bool): Whether to apply Gaussian smoothing before mesh generation
        smooth_sigma (float): Sigma for Gaussian smoothing
        
    Returns:
        dict: Dictionary containing:
            - vertices: Nx3 array of vertex coordinates
            - faces: Mx3 array of triangle face indices
            - normals: Nx3 array of vertex normals
            - num_vertices: Number of vertices
            - num_faces: Number of triangles
    """
    # Check if volume has any non-zero voxels
    if np.sum(volume) == 0:
        return {
            "vertices": np.array([]),
            "faces": np.array([]),
            "normals": np.array([]),
            "num_vertices": 0,
            "num_faces": 0
        }
    
    # Apply smoothing if requested
    if smooth:
        volume_processed = smooth_volume(volume, sigma=smooth_sigma)
    else:
        volume_processed = volume.astype(np.float32)
    
    try:
        # Generate mesh using marching cubes
        vertices, faces, normals, values = measure.marching_cubes(
            volume_processed,
            level=level,
            step_size=step_size,
            allow_degenerate=False
        )
        
        return {
            "vertices": vertices,
            "faces": faces,
            "normals": normals,
            "num_vertices": len(vertices),
            "num_faces": len(faces)
        }
    except Exception as e:
        # Handle case where marching cubes fails (e.g., no valid surface)
        return {
            "vertices": np.array([]),
            "faces": np.array([]),
            "normals": np.array([]),
            "num_vertices": 0,
            "num_faces": 0,
            "error": str(e)
        }


def generate_mesh_for_cluster(labels_stack: np.ndarray, 
                               cluster_id: int,
                               smooth: bool = True,
                               smooth_sigma: float = 1.0,
                               step_size: int = 1) -> dict:
    """
    Convenience function to generate a mesh for a specific cluster.
    
    Args:
        labels_stack (np.ndarray): 3D array of cluster labels
        cluster_id (int): The cluster ID to generate mesh for
        smooth (bool): Whether to apply smoothing
        smooth_sigma (float): Smoothing intensity
        step_size (int): Marching cubes step size
        
    Returns:
        dict: Mesh data including vertices, faces, normals, and stats
    """
    # Extract binary volume for this cluster
    cluster_volume = extract_cluster_volume(labels_stack, cluster_id)
    
    # Calculate volume statistics
    voxel_count = np.sum(cluster_volume)
    total_voxels = labels_stack.size
    volume_percentage = (voxel_count / total_voxels) * 100
    
    # Generate mesh
    mesh = generate_mesh(
        cluster_volume,
        smooth=smooth,
        smooth_sigma=smooth_sigma,
        step_size=step_size
    )
    
    # Add cluster-specific info
    mesh["cluster_id"] = cluster_id
    mesh["voxel_count"] = int(voxel_count)
    mesh["volume_percentage"] = round(volume_percentage, 2)
    
    return mesh


def generate_all_cluster_meshes(labels_stack: np.ndarray,
                                 smooth: bool = True,
                                 smooth_sigma: float = 1.0,
                                 step_size: int = 1,
                                 progress_callback=None) -> list:
    """
    Generate meshes for all clusters in the labels stack.
    
    Args:
        labels_stack (np.ndarray): 3D array of cluster labels
        smooth (bool): Whether to apply smoothing
        smooth_sigma (float): Smoothing intensity
        step_size (int): Marching cubes step size
        progress_callback: Optional callback(current, total) for progress updates
        
    Returns:
        list: List of mesh dictionaries, one for each cluster
    """
    unique_clusters = np.unique(labels_stack)
    meshes = []
    
    for i, cluster_id in enumerate(unique_clusters):
        mesh = generate_mesh_for_cluster(
            labels_stack,
            int(cluster_id),
            smooth=smooth,
            smooth_sigma=smooth_sigma,
            step_size=step_size
        )
        meshes.append(mesh)
        
        if progress_callback:
            progress_callback(i + 1, len(unique_clusters))
    
    return meshes
